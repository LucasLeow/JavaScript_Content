Learnings in this text:
    - NodeJS global object
    - NodeJS "fs" module
    - NodeJS Server using "http" module
        - Request | Response object
        - serving HTML using "fs" module (routes)
    - Simple Express App
    - ViewEngine (EJS)
        - using "views" & "partials"
        - creating .ejs files to serve dynamic HTML (using ejs tags <% %>)
    - Middleware
        - app.use(callback)
        - app.get(path, callback) (any middleware after this not executed since res sent)
    - MongoDB
        - setup
        - mongoose (Schema & Model) + sandbox testing routes
    
    
== 1 Intro & Setup ==
   
    - What is NodeJS

        - JS Runtime environment to run JS on computers
            - written in C++, wraps around V8 Engine
                - V8 Engine written in C++ by Google team, embedded in Chrome

        - Read & Write files on computers
        - Connect to database
        - Act as server for content

        - Lose access to DOM
            - cannot interact with HTML element using NodeJS
            - cannot use document.querySelector in Node
                - document part of "window" object


    Benefits of Node as BackEnd
        - No need to learn extra language for Backend (if alrdy familiar)
        - share code b/w front-end & back-end
        - massive community, library & frameworks


== 2 Node.js Basics ==


    -- 2.1 global object in NodeJS --
        (https://nodejs.org/api/globals.html#global-objects)
        
        - Inside browser, known as "window" object
            - load of methods & properties accessible

        - Inside Node, known as "global" object
            - don't have to use "global" prefix (implied)

            i.e setTimeout() instead of global.setTimeout()



    -- 2.2 modules & require --

        - modules are simply JS files
        - need separate modules to keep code neat (modularity)
        - require() will simply execute js file, no data imported / exported
        
        inside people.js:
            const people = ['person1', 'person2'];
            const ages = [20, 23];

            module.exports = {
                people,
                ages
            };

        inside main.js:

            const data = require('./people');
            console.log(data.people, data.ages);


        Destructuring objects:
            - must be same name as property exported
        
        eg:

        inside main.js:

            const { people, ages } = require('./people');

            console.log(people);


        Core modules in JS:
            - also known as built-in modules (ships with Node) 
            (https://www.w3schools.com/nodejs/ref_modules.asp)

                assert
                buffer
                child_process
                cluster
                crypto
                dgram
                dns
                domain
                events
                fs
                http
                https
                net
                os
                path
                punycode
                querystring
                readline
                stream
                string_decoder
                timers
                tls
                tty
                url
                util
                v8
                vm
                zlib

    -- 2.3 File System --

        - 1 of the core modules that ship with Node for file manipulation
        - good for small files, for larger files, use Stream (see Section 2.4)
        - Read | Create | Delete files / directories

        CHECK IF FILE / DIR EXIST:
            - fs.existsSync(path)
                - returns boolean

        READING FILES:

            - fs.readFile(path, callback(err, data))
                - readFile is an async function
                - fires callback upon completion
                - data in buffer format, to show txt, use .toString method

        eg:

            const fs = require('fs');

            fs.readFile('./docs/blog1.txt', (err, data)=> {
                if (err) {
                console.log(err); 
                }
                console.log(data.toString());
            });
        
        WRITING FILES:
            - Overwrites file with new content provided
            - if file not exist, will create new txt file

            - fs.writeFile(path, dataToWrite, callback());

        eg:

            const fs = require('fs');

            fs.writeFile('./docs/blog1.txt', "Hello World", ()=> {
                console.log('Data successfully written');
            });

        DIRECTORIES:

            - fs.mkdir(path, callback)
            - if dir already exist, throws error
                - best practice to check if folder exist

            - fs.rmdir(path, callback)
                - to remove directory

            eg:

                const fs = require('fs');

                if (fs.existsSync('./assets')) {
                    fs.rmdir('./assets', (err) => {
                        if (err) {
                            console.log(err);
                        }
                    console.log("dir deleted");
                    });
                } else {
                    fs.mkdir('./assets', (err)=>{
                    if (err) {
                        console.log(err);
                    }
                    console.log("directory created");
                })
                }
        
        DELETING FILES:

            - fs.unlink(path, callback(err))

            eg:

                if (fs.existsSync('./docs/blog1.txt')) {
                    fs.unlink('./docs/blog1.txt', (err) => {
                        if (err) {
                            console.log(err);
                        }
                        console.log("File deleted");
                    })
                }


    -- 2.4 Streams & Buffers --
        - To handle larger files
        - Also using fs module in JS

        Streams:
            - Start using data before finished loading
                - small chunks of data (buffer) passed down the stream
            - Like video streaming instead of downloading entire video before watching
            - for fs module, must load entire file before using

        
        Also using fs module

            1) READ STREAMS & WRITE STREAMS

                - readStream.on('data') : EventListener for data event on stream

            eg:
            
            const fs = require('fs');

            const path = './docs/largeFile.txt';
            const writePath = './docs/newFile.txt';

            const readStream = fs.createReadStream(path, { encoding: 'utf8' }); // encoding will convert buffer to string
            const writeStream = fs.createWriteStream(writePath);

            readStream.on('data', (buf)=>{
                console.log("-- New Buffer --");
                console.log(buf);

                writeStream.write('\n New Buffer \n');
                writeStream.write(buf);
            });


        - Pipe Stream -
            - Transfer Readable Stream data to Writable Stream

                eg:

                const fs = require('fs');

                const path = './docs/largeFile.txt';
                const writePath = './docs/newFile.txt';

                const readStream = fs.createReadStream(path, { encoding: 'utf8' }); // encoding will convert buffer to string
                const writeStream = fs.createWriteStream(writePath);

                readStream.pipe(writeStream);




== 3 Node Clients & Servers ==

    - communication b/w website & server
    - when running server side code, console log will be on server console, not browser

    IP Address
        - address assigned to each device connected to internet
    
    Domain
        - English name mapped to IP Addresses to make it easier to remember

    -- Creating Server in Node --
        - using http module in Node
        (https://www.w3schools.com/nodejs/nodejs_http.asp)

        1) create server.js file

                const http = require('http');

                // callback fn executes whenever requests received by server
                const server = http.createServer((req, res) => {
                    console.log('request made');
                });

                const PORT = 3000;

                // default is localhost
                server.listen(PORT, 'localhost', () => {
                    console.log(`Listening for requests on port ${PORT}`);
                });


        localhost: Loopback IP Address
            - 127.0.0.1 (Points back to own computer)
        
        Port Number:
            - A specific channel / Gateway on computer 
            - "doors" into computer for internet connection to different programs
            - 65,535 possible ports



== 4 Requests & Response Object ==


    REQUEST OBJECT: 

        - request object contains load of information
        - console log will show entire request object

                const server = http.createServer((req, res) => {
                    console.log(req);
                });

        - some useful request properties:
            - req.url (gives the url, useful for sending relevent response)
            - req.method (HTTP method of request)


                const server = http.createServer((req, res) => {
                    console.log(req.url, req.method);
                });

    
    RESPONSE OBJECT:
        
        - sent by server to browser

        Response headers
            - provide metadata to Client
            - some default automatically set

            eg:
                - what data to expect
                    - JSON
                    - text
                    - pdf
                    - html etc.

                - set cookies


                const server = http.createServer((req, res) => {
                    console.log(req.url, req.method);

                    res.setHeader('Content-Type', 'text/plain');
                    res.write('hello, world');
                    res.end();
                });

                To return HTML:
                

                const server = http.createServer((req, res) => {
                    console.log(req.url, req.method);

                    res.setHeader('Content-Type', 'text/html');
                    res.write("<h1> Hello world </h1>");
                    res.write("<p> Hello world </p>");
                    res.end();
                });

    -- RETURNING HTML PAGES --

        1) Create "views" dir to store html PAGES
        2) create index.html & initialize default template
            - add <h1> Home Page </h1> in body

        3) go to server.js

                const http = require('http');
                const fs = require("fs");

                const server = http.createServer((req, res) => {
                    console.log(req.url, req.method);

                    // set response header
                    res.setHeader('Content-Type', 'text/html');

                    // send html file
                    fs.readFile('./views/index.html', (err, data) => {
                        if (err) {
                            console.log(err);
                            res.end();
                        } else {
                            res.write(data);
                            res.end();
                        }
                    });
                });

                const PORT = 3000;
                server.listen(PORT, 'localhost', () => {
                    console.log(`Listening for requests on port ${PORT}`);
                });


    -- Basic Routing --

        - send desired resource according to URL provided

            1) Create about.html in "views" dir
                - add h1 : about
            2) Create error.html in "views" dir
                - add h1 : Error, page not found
            3) Go to server.js
                3.1) Checking url provided


                const http = require('http');
                const fs = require("fs");

                const server = http.createServer((req, res) => {
                    console.log(req.url, req.method);

                    let path = './views/';
                    switch(req.url) {
                        case '/' : 
                            path += 'index.html';
                            break;
                        case '/about': {
                            path += 'about.html';
                            break;
                        }
                        default: {
                            path += 'error.html';
                        }
                    }

                    // set response header
                    res.setHeader('Content-Type', 'text/html');

                    // send html file
                    fs.readFile(path, (err, data) => {
                        if (err) {
                            console.log(err);
                            res.end();
                        } else {
                            res.write(data);
                            res.end();
                        }
                    });
                });

                const PORT = 3000;
                server.listen(PORT, 'localhost', () => {
                    console.log(`Listening for requests on port ${PORT}`);
                });

    -- Status Codes --
        - 1xx - information
        - 2xx - successfully
        - 3xx - redirect
        - 4xx - client errors
        - 5xx - server errors
        

                    switch(req.url) {
                        case '/' : 
                            path += 'index.html';
                            res.statusCode = 200;
                            break;
                        case '/about': {
                            path += 'about.html';
                            res.statusCode = 200;
                            break;
                        }
                        default: {
                            path += 'error.html';
                            res.statusCode = 404;
                        }
                    }
            - In dev tools, network, can see status codes


    -- Redirecting of Resources --

                    switch(req.url) {
                        case '/' : 
                            path += 'index.html';
                            res.statusCode = 200;
                            break;
                        case '/about': {
                            path += 'about.html';
                            res.statusCode = 200;
                            break;
                        }
                    


                    // redirection here using setHeader

                                    case '/about-me': {
                                        console.log(path);
                                    
                                        res.writeHead(301, {
                                            Location: '/about'
                                        });
                                        
                                        break;
                                    }




                        default: {
                            path += 'error.html';
                            res.statusCode = 404;
                        }
                    }



== 5 Node Package Manager (npm) ==
    - packages not in node core
    - written by other users / companies
    - frameworks

    - automatically installed together with Node

    https://npmjs.com
        - search for different packages available

        -- Popular node packages --
            1) nodemon
                - helps to refresh server everytime changes saved

                    - npm install nodemon
                    - use "nodemon" cmd instead of "node"

    
    -- Creating package.json file --

        1) Create project directory
        2) npm init -y 
            package-lock.json
                - keeps track of depedencies of packages

            - dependencies 
                - tracks packages used in project

            - node_modules
                - all packages will be installed inside node_modules

    -- Sharing files --
        - node_modules may be very large
        - upload all project code except node_modules
        - download entire code into project directory
        - open project directory
            - npm install
                - automatically installs all dependencies

== 6 Express Framework ==
    - previously use "http" library to handle requests
    - Express framework helps manage routing / requests / server side routing / logic
    - Don't have to use Express, can simply use node

        1) create project directory
        2) npm i express
        3) create app.js in project dir

                const express = require('express');

                // Create instance of express object
                const app = express();

                app.listen(3000); // returns instance of server (can save in var for websockets)

                // 1st argument: url path to listen for, 2nd argument: callback when request received
                app.get('/', (req, res) => {
                    res.send('<p>Home App </p>'); // automatically infers content type & set in headers
                    // dont have to res.setHeader("Content-Type", 'text/html');
                });


            4) Creating Routing to deliver resources (HTML pages)
                    app.get('/', (req, res) => {
                        res.send("<p> Send automatically detects content-type </p>")// automatically infers content type & set in headers
                        res.sendFile('./views/index.html', {root: 'h:/SelfLearning/BackEnd/JavaScript/NodeJS_CrashCourse'}); 
                            - sendFile takes in absolute path
                            - therefore, if provide relative path, need to specify absolute path leading to resource folder
                    });

                    app.get('/about', (req, res) => {
                        res.sendFile('./views/about.html', {root: 'h:/SelfLearning/BackEnd/JavaScript/NodeJS_CrashCourse'});
                    });

                    app.get('/about-us', (req, res) => {
                        res.redirect('/about');
                    })

                    app.use((req, res) => {
                        res.status(404).sendFile('./views/error.html', {root: 'h:/SelfLearning/BackEnd/JavaScript/NodeJS_CrashCourse'});
                            - have to chain status since use() does not detect that the following is an error, its simply a middleware callback fn
                    })

                    // .use((req, res)=>) is a middleware that will fire whenever request received
                        - not scoped to any particular path
                        - will fire for any request regardless of URL if code manage to reach that point
                        - sequence matters, will fire if about any routes


== 7 View Engines (Serving Dynamic HTML Content) ==
    - using view / template engine
    - Express apps can use this easily
    - Several Templating Engine exists
        - Express Handlebars
        - Pug (different from HTML)
        - EJS (Simple)

            1) npm install ejs
            2) in app.js
                - app.set('view engine', 'ejs); // set() allows configuring app settings
                - By default, ejs search in "views" directory for HTML content
                - else, app.set('views', 'newViews'); // to set custom "views" dir
            3) go to "views" dir
                - create "index.ejs" file
                - init HTML template as per normal
            4) go to app.js
                - instead of sendFile, must render() view
                    app.get('/', (req, res)=> {
                        res.render('index'); // express look inside "view" dir, search for index.ejs
                    })
            5) create about.ejs & error.ejs
            6) Add routing to about.ejs & error.ejs in app.js
            7) create 'create.ejs' for '/blog/create' route
                - add form within create.ejs (refer to create.ejs for more info on HTML)
                
            8) ejs tags can be used to render dynamic data
                - <% const name = 'mario' %> // inside body tag
                    - runs as JS in server, not browser
                - <p> <%= name %> </p> 
                    - If want to output dynamic data, need to include '=' sign in ejs tag
                
            8.1)
                * Typically, data passed to view from app.js
                * usually, data retrieved from database, then app.js pass to views

                inside app.js:
                    app.render('index', { title: "Home"})

                - Then can use <%= title %> in index.ejs
            9) add dynamic titles for about, create, error

            10) add dynamic content for index.html

                in app.js
                app.get('/', (req, res) => {
                        const blogs = [
                            {title: "Yoshi find eggs", snippet: "Reprehenderit aliquip mollit laboris culpa ex nisi."},
                            {title: "Mario find peach", snippet: "Non occaecat nulla occaecat dolore proident velit esse consectetur laborum nisi reprehenderit dolor anim ut."},
                            {title: "How to defeat Bowser", snippet:"Dolor ex est enim eiusmod eiusmod laborum non ipsum laborum esse sint in."}
                        ];
                        res.render('index', {title:"Dynamic Home", blogs});
                    });

                in index.ejs:

                            <div class="blogs content">
                                <h2>All Blogs</h2>
                                <% if (blogs.length > 0) { %>
                                        <% blogs.forEach((item) => { %>
                                            <h3 class="title"><%= item.title %></h3>
                                            <p class="snippet"><%= item.snippet %></p>
                                        <% }) %>
                                <% } else { %>
                                    <p>There are no blogs to display..</p>
                                <% } %>
                            </div>

            -- How does EJS Templates work? --
                1) EJS files live on server
                2) View file passed to EJS engine in server to process
                    - engine looks for <%= %> ejs tags
                    - When find tags, process & converts to valid HTML syntax
                    - Known as server-side rendering

            -- EJS tags --
                <%= : equal signs escape special characters, resulting in string value, used for specifying values
                <%- : Does not escape characters, used for importing


            -- Partials --
                - Common content in all pages
                - Put in single ejs file & import to all other files needing the common content
                - known as Partial templates

                1) create dir "partials" inside "views" dir
                    - create nav.ejs | head.ejs | footer.ejs

                    inside nav.ejs:

                        <nav>
                            <div class="site-title">
                                <a href="/"><h1><%= name %> Blog</h1></a>
                                <p><%= name %> Blog Site</p>
                            </div>
                            <ul>
                                <li><a href="/">Blogs</a></li>
                                <li><a href="/about">About</a></li>
                                <li><a href="/blogs/create">New  Blog</a></li>
                            </ul>
                        </nav>

                    2) go to index.ejs
                        - in <body>, specify:
                        (at the location where you would like to put the nav tags)
                            <%- include('./partials/nav.ejs') %>

                    3) repeat for
                        - about
                        - create
                        - error

                    
                    4) go to index.ejs
                        - copy contents in <head> tag & paste into head.ejs

                        then:
                         <%- include('./partials/head.ejs') %> in relevant ejs files

                    5) write footer.ejs

                            <footer>
                                Copyright &copy; Lucas  Blog 2023
                            </footer>

                    6) <%- include('./partials/footer.ejs') %> in relevant ejs files

== 8 Middleware ==
    - Any code which runs on the server
    -  in-between getting a request & sending a response
        - after receiving request
        - before sending back response
    - Can have > 1 middleware function
    - code is executed before response is sent back to client
    - runs from top to bottom
        - sequential execution of middleware code

        eg:
            Line 1: app.use(func)
            Line 2: app.get('/', func)
            Line 3: app.use(func)

            - if send a '/' request,
                - Line 1 executes
                - Line 2 executes & sends a response back to client
                - Line 3 will not execute since response already sent back

        Middleware use cases:

            - Logger middleware to log details of requests
            - Authentication middleware for protected routes
            - Parser middleware to parse json
            - Return 404 pages middleware
                - app.use(func) at the bottom to catch any uncaught routes
            etc.

        Middleware application in project:
            * Have to use "next" callback to tell browser what to do next after executing middleware()
            - else, after executing app.use((req, res)=>{}), browser will hang as it doesn't know what to do next
                app.use((req, res, next)=>{})

            1) go to app.js above app.get('/')

                app.use((req, res, next) => {
                    console.log("new request made: ");
                    console.log('host: ', req.hostname);
                    console.log('path', req.path);
                    console.log('method', req.method);
                    next(); // middleware finished, move to next step
                });

    3rd party middlewares:
        - created by other people
        - "morgan" : logger middleware (used in this project)
        - "helmet" : security middleware
        - cookies | sessions | validation etc. just search online


        Using "morgan" logger middleware in project:
            1) go to project dir & npm install morgan
            2) go to app.js
                
                1) const morgan = require("morgan");
                2) remove app.use() middleware for logging added earlier
                3) app.use(morgan('dev')); 'dev' is the argument for type of formatting for logging
                    - add below app.listen(3000);
                    - refer to morgan documentation for types of formatting keyword
        
    Using Middleware to serve static files (css files)
        - imgs are also static files
        - server protects access to files stored in server
        - need to specify to server what files can be accessed (public)
            
            * Utilize "static" middleware that comes with Express
                - to give access to static file (styles.css)
                
                    1) Go to app.js
                    2) app.use(express.static('public'));
                        - 'public' is a directory that contains static resources
                        - any static files within 'public' will be made available
                    3) create "styles.css" inside "public"
                    4) create simple css 
                        body {
                            background: crimson;
                        }
                    5) go to head.ejs
                        - <link rel="stylesheet" href="styles.css">
                            - express will automatically look into "public" directory
                            - since "public" was given as argument (see step 2)

                    6) Go to head.ejs
                        - copy all content within <style> into styles.css
                        - remove <style> tags
                        - include <link rel="stylesheet" href="styles.css"> in place of <style> tags



== 9 NodeJS MongoDB ==
    - SQL vs NoSQL
    
    SQL
        - Tables | Rows | Columns
    NoSQL
        - Collections | Documents
        - Each collection used to store a particular type of document
        
            User Collection : Stores user documents
            Blog Collection : Stores Blog documents

                Document: (very similar to JSON)
                {
                    "id": 12345,
                    "title": "Blog 1",
                    "snippet": "Learning Programming",
                    "body": "Learning programming is my hobby.."
                }

            Collection can store many documents
            - perform CRUD on documents

    MongoDB
        - download & use locally
        - use via cloud services (MongoDB Atlas) (easier to manage)
                1) Create new cluster
                    - 3 types: Serverless | Dedicated (Most costly) | Shared (Free)
                2) Once done, go to cluster & open Collections
                3) Create Database within Cluster
                    - Database name (project name)
                        - node-crash-course
                    - Collection name (related to content it is storing)
                        - blogs
                        - payments
                        - employees (etc.)
                4) Create access to db for connection b/w app & db
                    - on mongoDB, go to Database Access (under security)
                    - Add New Database User
                        - user & password
                        - Built-In-Role: Access Modifier (Read & Write to any database)
                5) Go back to Database & click "connect" to cluster
                    - select connection method (connect to application) (drivers)
                    - copy connection string
                    - go to app.js
                        const dbURI = <connectionString>
                6) Can connect using regular mongoDB api
                    - Mongoose (Object Document Mapping Library)
                        - wraps the standard mongoDB API
                        - creates data model that has methods to perform CRUD / manipulate data etc.

                        eg:
                            To work with User Collection, create corresponding User Model
                                - User.get() | User.findbyId() etc.
                                - Blog.deleteOne() etc.

                        How Mongoose work:

                            Step 1: Create Schema
                            Schemas:
                                - defines structure of data / document
                                eg:
                                User Schema:
                                    - name (string), required
                                    - age (number)
                                    - bio (string), required

                                Blog Schema:
                                    - title (string), required
                                    - snippet (string), required
                                    - body (string), required
                            
                            Step 2: Create Model based on provided Schema
                                - Model connects to the actual db in mongoDB

                            - Blog Model Built from Blog Schema
                            - Blog Model have static & instance methods to interact with database
                                - CRUD operations

                7) npm i mongoose
                8) go to app.js
                        const mongoose = require("mongoose");

                        //"mongodb+srv://<username>:<password>@lucascluster.hr7yd6q.mongodb.net/<dbname>?retryWrites=true&w=majority";

                        const dbURI = "mongodb+srv://testlucas:evilred@lucascluster.hr7yd6q.mongodb.net/node-crash-course?retryWrites=true&w=majority";
                       

                    // run app.listen(PORT) only after connection to DB successful
                        mongoose.connect(dbURI, {useNewUrlParser:true, useUnifiedTopology: true})
                        .then((result) => {
                            console.log("Connected to db");
                            app.listen(3000); // returns instance of server (can save in var for websockets)
                        })
                        .catch((err) => {console.log(err)});

                        // mongoose.connect() returns a promise, can use .then() & .catch() chain

                9) create "models" dir
                10) create blog.js inside "models" dir

                    const mongoose = require("mongoose");
                    const Schema = mongoose.Schema;

                    const blogSchema = new Schema({
                        title: {
                            type: String,
                            required: true
                        },
                        snippet: {
                            type: String,
                            required: true
                        },
                        body: {
                            type: String,
                            required: true
                        }
                    }, { timestamps: true }); // generates timestamps whenever CRUD takes place

                const Blog = mongoose.model('Blog', blogSchema);
                        - convention is capital letter
                        - 1st argument : Name of Collection
                            - automatically pluralize it ( eg. Blog -> blogs )
                        - 2nd argument : Schema
                
                module.exports = Blog;

            
            11) create sandbox route to test connection
                - go to app.js

                    const Blog = require('./models/blog');

                    app.get("/add-blog", (req, res) => {
                        const blog = new Blog({
                            title: "new blog",
                            snippet: "about new blog",
                            body: "body of new blog"
                        });
                        blog.save()
                        .then((result) => {
                            res.send(result);
                        })
                        .catch((err) => {
                            console.log(err);
                        })
                    })

                    - test connection by using:
                        localhost:3000/add-blog

                    // Create route to retrieve all blogs
                    app.get("/all-blogs", (req, res) => {
                        Blog.find()
                        .then((result) => {
                            res.send(result); // send result to browser
                        })
                        .catch((err)=>{
                            console.log(err);
                        }); 
                    });

                    // Create route to retrieve single blog
                            app.get("/single-blog", (req, res) => {
                                Blog.findById("64a78616f9268c1d5eaf15a5")
                                .then((result) => {
                                    res.send(result);
                                })
                                .catch((err)=>{console.log(err)});
                            });

                                - Every document in mongoDB have unique id when created
                                - type is ObjectId but mongoose converts to String (vice-versa)

                12) Delete sandbox routes after testing db connection
                    

                13) in app.js, create route to display blog info. on webpage
                    - done by retrieving data from db instead of hardcoding

                            app.get('/', (req, res) => {
                                Blog.find()
                                .then((result) => {
                                    res.render('index', {title: "Home", blogs: result});
                                })
                                .catch((err) => {
                                    console.log(err);
                                });
                            });


                Blog.find().sort({ createdAt: -1}); // -1 means sort descending based on createdAt
                result:
                [
                    {
                        _id: new ObjectId("64a78616f9268c1d5eaf15a5"),
                        title: 'new blog',
                        snippet: 'about new blog',
                        body: 'body of new blog',
                        createdAt: 2023-07-07T03:27:18.492Z,
                        updatedAt: 2023-07-07T03:27:18.492Z,
                        __v: 0
                    }
                ]


== 10 GET, POST, DELETE Requests ==

    - GET : retrieve data from db
    - POST : create new data (idempotent) (only run once, avoid duplicates)
    - DELETE : delete data
    - PUT : update existing data
    
    localhost:3000/blogs
        - GET
        - POST
        * Possible for 1 route to perform > 1 CRUD actions
            - handled differently based on data submitted

        1) Think about all the routes required to perform CRUD actions

                - localhost:3000/blogs : GET webpage with all blogs
                    - already completed with Blog.find()
                - localhost:3000/blogs/create: GET webpage with webform
                    - already completed with res.render('index')
                - localhost:3000/blogs : POST new blog (possible to have same route with different CRUD action)
                - localhost:3000/blogs/:id GET specific blog
                - localhost:3000/blogs/:id :DELETE specific blog
                - localhost:3000/blogs/:id : PUT (update specific blog)
